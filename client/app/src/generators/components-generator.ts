/**
 * This file uses templates to generate a folder of files containing a set of React components for each service class / database model
 * that is generated from the backend with `@hey-api/client-axios`
 *
 * JSX and other parts will need to be manually updated.
 *
 * @module
 */
import fs from "fs"
import path from "path"
import type ts from "typescript"

import { getAppRoot } from "../utils/utils.ts"
import { ensureDevMode } from "../config/config.ts"

import {
    getClassInfo,
    progFromSourcePath,
    getTypeDeclarationsWithInfo,
    propertiesInfoToRecord,
    type TypeDeclPropertiesInfo
} from "../utils/tsUtils.ts"

import { camelToCapitalCase, camelToHyphenCase } from "../utils/stringUtils.ts"

ensureDevMode()


/**
 * Generates a series of CRUD components using a template directory for each database model / service class
 * that was generated by `@hey-api-client-axios`.
 *
 * The components generated are for both admin and public views, and include associated styling.
 *
 * Specific sections tagged with start/end comments will either generate special values based on the model,
 * or mark unique sections in the generated files that are to be retained when they are generated from the template again.
 *
 * @privateRemarks It would probably be better to have a single named unique-comment and do a search and replace on each match
 *
 *
 * @param generatedClientDir - The directory with the services and types files generated by `@hey-api-client-axios`
 * @param componentTemplateDir - The directory with the components template files
 * @param componentsOutputDir - The directory where a new directory of files will be created for each service class
 * @param excludeServices - A list of generated service class names to not generate components for
 */
const generateComponents = (
    generatedClientDir: string,
    componentTemplateDir: string,
    componentsOutputDir: string,
    excludeServices?: string[]
): void => {
    console.log( `Generating components from template directory ${componentTemplateDir}...` )

    const typesFilePath = path.join( generatedClientDir, "types.gen.ts" )
    const servicesFilePath = path.join( generatedClientDir, "services.gen.ts" )

    const templateFiles = fs.readdirSync( componentTemplateDir, { withFileTypes: true } )
    const templateFilesNames = [
        "templates-admin-page.tsx",
        "templates-page.tsx",
        "templates-style.scss",
        "TemplatesList.tsx",
        "TemplatesListItem.tsx",
        "TemplatesDisplay.tsx",
        "TemplatesDisplayItem.tsx",
        "TemplateAddEdit.tsx",
        "TemplateView.tsx"
    ]
    type TemplateFilesNames = typeof templateFilesNames[number]
    const templateFilesContents: Record<TemplateFilesNames, string> = {}

    for ( const entry of templateFiles ) {
        if ( !entry.isFile() )
            continue
        if ( !templateFilesNames.includes( entry.name ) )
            throw new Error( `Unexpected file in template directory ${entry.name}` )

        templateFilesContents[ entry.name ] = fs.readFileSync( path.join( entry.parentPath, entry.name ) ).toString()
    }

    if ( !fs.existsSync( componentsOutputDir ) )
        fs.mkdirSync( componentsOutputDir )

    const templateModelName = "Blog"
    const [ first, ...rest ] = templateModelName
    const camelCaseTemplateModelName = first.toLowerCase() + rest.join( "" )

    excludeServices ??= []
    excludeServices = excludeServices.map( serviceClassName => serviceClassName.toLowerCase() )
    const serviceClassInfos = getClassInfo( servicesFilePath )

    const { program: _, typeChecker, programSourceFiles: __, targetSourceFile } = progFromSourcePath( [ typesFilePath ], typesFilePath )
    const typeDeclarationsWithInfo = getTypeDeclarationsWithInfo( typeChecker, targetSourceFile as ts.SourceFile )

    const serviceClassNames = serviceClassInfos
        .map( classInfo => classInfo.name )
        .filter( className =>
            !excludeServices.includes( className.toLowerCase() ) && !excludeServices.includes( className.replace( "Service", "" ).toLowerCase() )
        )

    // console.log( templateModelName, serviceClassNames )

    for ( const serviceClassName of serviceClassNames ) {
        console.log( `Creating components and associated files for '${serviceClassName}'` )

        const newModelName = serviceClassName.replace( "Service", "" )
        const [ first, ...rest ] = newModelName
        const camelCaseNewModelName = first.toLowerCase() + rest.join( "" )
        const hyphenatedModelName = camelToHyphenCase( camelCaseNewModelName )

        const thisComponentsOutputDir = path.join( componentsOutputDir, `${newModelName.toLowerCase()}s/` )
        if ( !fs.existsSync( thisComponentsOutputDir ) )
            fs.mkdirSync( thisComponentsOutputDir )

        // ItemType destructuring
        const serviceClassResponseProperties = typeDeclarationsWithInfo[ `Get${newModelName}Response` ]
        const serviceClassResponsePropertiesInfo = serviceClassResponseProperties.propertiesInfo?.find( prop => prop.name === "data" )
        const responsePropertiesInfoRecord = propertiesInfoToRecord(
            serviceClassResponsePropertiesInfo?.valuePropertiesInfo as TypeDeclPropertiesInfo[]
        )
        const responsePropertiesInfoRecordKeysString = Object.keys( responsePropertiesInfoRecord ).map( k => `${k},` ).join( " " )
        const destructuredItemTypeString = `const { ${responsePropertiesInfoRecordKeysString} } = ${camelCaseNewModelName}`
        const destructuredFormItemTypeString = `const { ${responsePropertiesInfoRecordKeysString} } = editable${newModelName}`

        const serviceClassRequestProperties = typeDeclarationsWithInfo[ `${newModelName}CreateRequest` ]
        const serviceClassRequestPropertiesInfo = serviceClassRequestProperties.propertiesInfo
        const requestPropertiesInfoRecord = propertiesInfoToRecord(
            serviceClassRequestPropertiesInfo as TypeDeclPropertiesInfo[]
        )
        // const requestPropertiesInfoRecordKeysString = Object.keys( requestePropertiesInfoRecord ).map( k => `${k},` ).join( " " )

        const keySpacingLength = Math.max( ...Object.keys( requestPropertiesInfoRecord ).map( str => str.length ) )
        const propertyKeyToValue: Record<string, string> = {
            "id"     : "-1",
            "userId" : "authExtraState.jwtResponse?.user.id"
        }
        const propertiesInfoRecordKeysStringLines = Object.keys( requestPropertiesInfoRecord ).map(
            k => `        ${k} ${" ".repeat( keySpacingLength - k.length )}: ${propertyKeyToValue[ k ] || "undefined"},`
        ).join( "\n" )
        const authExtraStateSelector = Object.keys( requestPropertiesInfoRecord ).includes( "userId" )
            ?"const { extraState: authExtraState } = useAppSelector( ( state ) => state.auth )\n\n    "
            : ""
        const destructuredFormDefaultItemTypeString =
            `${authExtraStateSelector}const default${newModelName} = {\n${propertiesInfoRecordKeysStringLines}\n    }`


        // AddEdit.tsx Form JSX
        const excludedPropKeysFromForm = [
            "id", "createdAt", "updatedAt", // Base model
            "user", // associations

            "tags",// Blog
            "bookingType",// Booking
            "isPublic", "authorName",// Feedback
            // Roles
            // Tags
            "fullName", "isAdmin", "isStaff"// Users
        ]
        const formElement = ( propKey: string, spacing: number, inputType?: string, required?: boolean ) => {

            const requestPropType = requestPropertiesInfoRecord[ propKey ]
            // const responsePropType = responsePropertiesInfoRecord[ propKey ] || requestPropType

            const capitalizedPropName = camelToCapitalCase( propKey )
            const spaces = " ".repeat( spacing )


            const isPossiblyUndefined = requestPropType.includes( "undefined" )
            const isBoolean = requestPropType.includes( "boolean" )
            const isDate = requestPropType.includes( "Date" )

            required = !isPossiblyUndefined
            required = isBoolean ? false : required

            inputType ??= "text"
            inputType = isBoolean
                ? "checkbox"
                : isDate
                    ? "datetime-local"
                    : propKey === "cssColour"
                        ? "color"
                        : inputType

            const inputValue = isDate
                ? `convertISOToDateInputValue( ${propKey}, true )`
                : isBoolean
                    ? `Boolean( ${propKey} ).toString()`
                    : propKey

            const checkedAttr = isBoolean
                ? `\n${spaces}    checked={${propKey}}`
                : ""

            const elementName = [ "content", "description" ].includes( propKey ) ? "textarea" : "input"

            const typeAttribute = elementName === "textarea"
                ? ""
                : `\n${spaces}    type="${inputType}"`

            const requiredAttribute = required
                ? `\n${spaces}    required`
                : ""
            const requiredOption = required
                ? `\n${spaces}        required : "${capitalizedPropName} is required"`
                : ""

            return `
${spaces}<label>
${spaces}    ${capitalizedPropName}:
${spaces}    {formErrors.${propKey} && <div className="form-errors"><small>{formErrors.${propKey}.message}</small></div>}
${spaces}</label>
${spaces}<${elementName}${typeAttribute}${checkedAttr}
${spaces}    value={${inputValue} || ""}
${spaces}    aria-invalid={formErrors.${propKey} ? "true" : "false"}${requiredAttribute}

${spaces}    {...register( "${propKey}", {
${spaces}        onChange${required ? " " : ""}: onFormStateChange,${requiredOption}
${spaces}    } )}
${spaces}/>`
        }


        for ( const [ fileName, fileContents ] of Object.entries( templateFilesContents ) ) {

            // Create output names
            const newFileName = fileName.replace( templateModelName, newModelName )
                .replace( camelCaseTemplateModelName, camelCaseNewModelName )
                .replace( "Template", newModelName )
                .replace( "template", camelCaseNewModelName )
            const componentFileOutputPath = path.join( thisComponentsOutputDir, newFileName )

            if ( fs.existsSync( componentFileOutputPath ) && ( fileName.endsWith( ".css" ) || fileName.endsWith( ".scss" ) ) )
                continue

            // Data attributes from ItemType
            const dataAttributesRegex = new RegExp(
                "^(?<spacing>\\s+)\\/\\* start:element-data-attributes \\*/.*\\* end:element-data-attributes \\*\\/", "gms"
            )
            const dataAttributesSpacing = dataAttributesRegex.exec( fileContents )?.groups?.spacing?.toString().length
            const elementDataAttributes = Object.keys( responsePropertiesInfoRecord ).map(
                propKey => {
                    // const possiblyUndefined = responsePropertiesInfoRecord[ propKey ].includes( "undefined" )
                    // const isNumber = responsePropertiesInfoRecord[ propKey ].includes( "number" )
                    // const propValue = ( possiblyUndefined || isNumber ) ? `String( ${propKey} )` : propKey
                    const propValue = propKey
                    const hyphenatedPropKey = camelToHyphenCase( propKey )
                    return `${" ".repeat( dataAttributesSpacing || 4 )}data-${hyphenatedModelName}-${hyphenatedPropKey}={${propValue}}`
                }
            ).join( "\n" )


            // Form hidden attributes
            const formHiddenAttributesRegex = new RegExp(
                "^(?<spacing>\\s+)\\{/\\* start:form-hidden-inputs \\*/.*\\* end:form-hidden-inputs \\*\\/}", "gms"
            )
            const formHiddenAttributesSpacing = formHiddenAttributesRegex.exec( fileContents )?.groups?.spacing?.toString().length
            const formHiddenAttributesSpaces = " ".repeat( ( formHiddenAttributesSpacing || 5 ) )
            const formHiddenAttributes = Object.keys( responsePropertiesInfoRecord )
                .filter( propKey => propKey.includes( "userId" ) )
                .map(
                    propKey =>
                        `${formHiddenAttributesSpaces}<input type="hidden" id="userId" name="${propKey}" value={ ${propKey} || undefined }/>`
                ).join( "\n" )


            // Form Inputs
            const formGridElementsRegex = new RegExp(
                "^(?<spacing>\\s+)\\{/\\* start:addedit-form-items \\*/.*\\* end:addedit-form-items \\*\\/}", "gms",
            )
            const formGridElementsSpacing = formGridElementsRegex.exec( fileContents )?.groups?.spacing?.toString().length
            const formGridElements = Object.fromEntries(
                Object.keys( responsePropertiesInfoRecord )
                    .filter( key => !excludedPropKeysFromForm.includes( key ) && !key.includes( "Id" ) )
                    .map(
                        propKey => [ propKey, formElement( propKey, ( formGridElementsSpacing || 5 ) - 2 ) ]
                    )
            )
            const formGridElementsString = Object.values( formGridElements )
                .join( "\n" )

            const convertDateFuncImport = "\nimport { convertISOToDateInputValue } from \"../../../utils/timeUtils.ts\""
            const addConvertDateFuncImport = formGridElementsString.includes( "convertISOToDateInputValue" ) && fileName.endsWith( "AddEdit.tsx" )


            // Check existing files and extract sections
            const foundComponentContent: Record<string, string> = {
                "unique-content-pre" : "",
                "unique-content"     : "",
                "unique-imports"     : "",
                "unique-jsx"         : "",
            }
            const uniqueContentPreRegex = new RegExp(
                "(\\/\\* start:component-unique-content-pre \\*\\/)(?<content>.*)(\\/\\* end:component-unique-content-pre \\*\\/)", "gms"
            )
            const uniqueContentRegex = new RegExp(
                "(\\/\\* start:component-unique-content \\*\\/)(?<content>.*)(\\/\\* end:component-unique-content \\*\\/)", "gms"
            )
            const uniqueImportsRegex = new RegExp(
                "(\\/\\* start:component-unique-imports \\*\\/)(?<content>.*)(\\/\\* end:component-unique-imports \\*\\/)", "gms"
            )
            const uniqueJSXRegex = new RegExp(
                "(\\{/\\* start:component-unique-jsx \\*\\/})(?<content>.*)({\\/\\* end:component-unique-jsx \\*\\/})", "gms"
            )
            if ( fs.existsSync( componentFileOutputPath ) ) {
                const existingTemplatedFileContents = fs.readFileSync( componentFileOutputPath ).toString()

                foundComponentContent[ "unique-content-pre" ] = uniqueContentPreRegex.exec( existingTemplatedFileContents )?.groups?.content || "\n"
                foundComponentContent[ "unique-content" ] = uniqueContentRegex.exec( existingTemplatedFileContents )?.groups?.content || "\n"
                foundComponentContent[ "unique-imports" ] = uniqueImportsRegex.exec( existingTemplatedFileContents )?.groups?.content || "\n"
                foundComponentContent[ "unique-jsx" ] = uniqueJSXRegex.exec( existingTemplatedFileContents )?.groups?.content || "\n"
            }

            foundComponentContent[ "unique-imports" ] = addConvertDateFuncImport
                ? convertDateFuncImport + foundComponentContent[ "unique-imports" ].replaceAll( convertDateFuncImport, "" )
                : foundComponentContent[ "unique-imports" ]

            Object.keys( foundComponentContent ).forEach(
                k => {
                    foundComponentContent[ k ] ||= "\n"
                }
            )

            const componentUniqueContentPre =
                `/* start:component-unique-content-pre */${foundComponentContent[ "unique-content-pre" ]}/* end:component-unique-content-pre */`
            const componentUniqueContent =
                `/* start:component-unique-content */${foundComponentContent[ "unique-content" ]}/* end:component-unique-content */`
            const componentUniqueImports =
                `/* start:component-unique-imports */${foundComponentContent[ "unique-imports" ]}/* end:component-unique-imports */`
            const componentUniqueJSX =
                `{/* start:component-unique-jsx */}${foundComponentContent[ "unique-jsx" ]}{/* end:component-unique-jsx */}`

            // Do the replacements
            const newFileContents  = fileContents
            // Change the name
                .replaceAll( templateModelName, newModelName )
                .replaceAll( camelCaseTemplateModelName, camelCaseNewModelName )
                .replaceAll( templateModelName.toLowerCase(), newModelName.toLowerCase() )
                .replaceAll( templateModelName.toUpperCase(), newModelName.toUpperCase() )
                .replaceAll( "Template", newModelName )
            // Update imports for the subdir
                .replaceAll( "from \"../", "from \"../../" )
            // Component unique content sections
                .replaceAll( uniqueImportsRegex, componentUniqueImports )
                .replaceAll( uniqueContentPreRegex, componentUniqueContentPre )
                .replaceAll( uniqueContentRegex, componentUniqueContent )
                .replaceAll( uniqueJSXRegex, componentUniqueJSX )
            // Destructuring
                .replaceAll(
                    new RegExp( "\\/\\* start:props-item-type-destructuring \\*/.*\\* end:props-item-type-destructuring \\*\\/", "gms" ),
                    destructuredItemTypeString
                )
                .replaceAll(
                    new RegExp( "\\/\\* start:form-item-type-destructuring \\*/.*\\* end:form-item-type-destructuring \\*\\/", "gms" ),
                    destructuredFormItemTypeString
                )
                .replaceAll(
                    new RegExp(
                        "\\/\\* start:form-default-item-type-destructuring \\*/.*\\* end:form-default-item-type-destructuring \\*\\/", "gms"
                    ),
                    destructuredFormDefaultItemTypeString
                )
            // Data attributes for any element
                .replaceAll( dataAttributesRegex, elementDataAttributes )
            // *AddEdit.tsx Form
                .replaceAll( formHiddenAttributesRegex, formHiddenAttributes ) //Form Hidden attributes
                .replaceAll( formGridElementsRegex, formGridElementsString ) // Inputs and Labels


            fs.writeFileSync( componentFileOutputPath, newFileContents )
            // console.log( `component file saved to ${newFileName}` )
        }

        console.log( `Created component files at ${thisComponentsOutputDir}` )

    }

    console.log( "Component generation complete" )

}


const appRoot = getAppRoot( import.meta.dirname )
const isRunDirectly = import.meta.filename.includes( process.argv[ 1 ] )
if ( isRunDirectly )
    generateComponents(
        path.join( appRoot, "src/api-client/" ),
        path.join( appRoot, "src/components/template-components/" ),
        path.join( appRoot, "src/components/generated/" ),
        [ "AuthService" ]
    )


export { generateComponents }