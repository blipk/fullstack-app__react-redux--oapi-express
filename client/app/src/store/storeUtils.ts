/**
 * This file contains utility functions for generating Redux slices from the `@hey-api/client-axios` generated client and schema
 *
 * @module
 */

import { createSlice, createAsyncThunk, type Draft } from "@reduxjs/toolkit"
import type {
    Slice, SliceSelectors, SliceCaseReducers,
    AsyncThunk, ActionReducerMapBuilder,
    PayloadAction,
    // ActionCreator, PayloadAction,
} from "@reduxjs/toolkit"

import { AxiosError } from "axios"
// import type { AxiosRequestConfig, AxiosResponse } from "axios"

import type { Config, RequestOptionsBase, RequestResult, Options } from "@hey-api/client-axios"


import type {
    ApiDataResponseBody,
    // ApiErrorsTypeUnion,
    AppAsyncThunkConfig,
    AppSliceState,
    AppThunkErrors,
    // AsyncThunkConfig,
} from "./storeTypes.ts"
import { SliceStatus } from "./storeTypes.ts"
import type { Pluralize } from "../utils/typeUtils.ts"
import { getMethodNames, type ClassConstructor } from "../utils/utils.ts"
import { checkAndSetAccessToken } from "./store.ts"

/** Not exported by Redux for some reason */
type WritableDraft<T> = {
    -readonly [K in keyof T]: Draft<T[K]>;
};

/** Not exported by `@hey-api/client-axios` - used for {@link MethodFn} */
type BaseInputOptions<ThrowOnError extends boolean> = Omit<RequestOptionsBase<ThrowOnError>, "method" | "url">

/** Return type of the Service class methods that are generated by `@hey-api/client-axios` */
type MethodFn<
    Data = unknown,
    TError = unknown,
    OptionsType extends Config & Record<string, unknown> = Config & Record<string, unknown>,
    ThrowOnError extends boolean = false,
> = (
options:
    Options<OptionsType, ThrowOnError> & BaseInputOptions<ThrowOnError>
)
 => RequestResult<Data, TError, ThrowOnError>


/** Redux `createAsyncThunk` method bound with the applications AsyncThunkConfig */
const appAsyncThunk: ReturnType<typeof createAsyncThunk.withTypes<AppAsyncThunkConfig>> = createAsyncThunk.withTypes<AppAsyncThunkConfig>()


/**
 * Factory function for making Redux async thunks from our generated `@hey-api/client-axios` service methods
 *
 * @param sliceName - The name of the slice
 * @param actionName - The name of the thunk action
 * @param serviceMethod - The method from the generated `@hey-api/client-axios` client for this thunk
 * @param extraRequestOptions - any extra options to pass to the service method
 *
 * @returns An AsyncThunk maker function that takes type arguments for the AsyncThunks options/params and return types
 */
const asyncThunkFactory = <
    DataType extends Record<string, unknown> = Record<string, unknown>,
    OptionsType extends Record<string, unknown> = Record<string, unknown>,
    ThrowOnError extends boolean = false
>(
        sliceName: string,
        actionName: string,
        serviceMethod: MethodFn<ApiDataResponseBody<DataType>, AppThunkErrors, OptionsType, ThrowOnError>,
        extraRequestOptions?: BaseInputOptions<ThrowOnError>
    ): <PassedOptionsType extends OptionsType = OptionsType,
        PassedReturnType extends ApiDataResponseBody<DataType> = ApiDataResponseBody<DataType>>
            ( ) => ReturnType<typeof appAsyncThunk<PassedReturnType, Options<PassedOptionsType, ThrowOnError>, AppAsyncThunkConfig>> => {

    const typePrefix = `${sliceName}/${actionName}`

    // Returned, ThunkArg
    return <
        PassedOptionsType extends OptionsType = OptionsType,
        PassedReturnType extends ApiDataResponseBody<DataType> = ApiDataResponseBody<DataType>,
    >( ) =>
        appAsyncThunk<
        PassedReturnType, // RETURN TYPE
        Options<PassedOptionsType, ThrowOnError>,
        AppAsyncThunkConfig
    >(
        typePrefix,
        async( options, thunkAPI ) => {
            console.log( `Fetching ${typePrefix}...` )
            checkAndSetAccessToken()
            const response =
            await serviceMethod( { ...options, ...extraRequestOptions } )
                .then( ( axiosResult ) => {
                    if ( axiosResult instanceof AxiosError ) {
                        console.log( "serviceMethod ERROR: ", axiosResult )

                        // https://redux.js.org/faq/actions#why-should-type-be-a-string-why-should-my-action-types-be-constants
                        // const serializableResponse = {
                        //     ...axiosResult,
                        //     ...{ request: undefined, config: undefined }
                        // }

                        const response = axiosResult.code === "ERR_NETWORK" || !axiosResult.response
                            ? { message: "Network Error", errors: [ { message: "Network Error - try again later" } ] }
                            : axiosResult.response.data //`axiosResult.errors` is the same - the generated API service must be handling this

                        console.log( "serviceMethod ERROR RESPONSE", response )

                        return thunkAPI.rejectWithValue( response )
                    }

                    console.log( "DATA: ", axiosResult.data )
                    return axiosResult.data as PassedReturnType
                } )
                .catch( ( error: unknown ) => {
                    console.log( "CAUGHT ERROR", error )
                    return thunkAPI.rejectWithValue(
                        { message: "Network Error", errors: [ { message: ( error as Error ).message } ] }
                    )
                }
                )

            return response
        }
    )
}


/**
 * Factory function that takes a class generated by `@hey-api/client-axios`
 * and turns all its methods into a set of Redux Async Thunks using {@link asyncThunkFactory}
 *
 * @param sliceName - The name of the slice - the generated Async thunks will be named `{sliceName}/{apiServiceMethodName}`
 * @param apiService - The service class from the generated `@hey-api/client-axios` client
 *
 * @typeParam DataType - The type of the data that all the service methods resolve to
 * @typeParam LiteralName - String literal type of the sliceName
 * @typeParam T - The type of `apiService` - the generated service class
 * @typeParam ThrowOnError - internal to `@hey-api/client-axios` options
*/
const asyncThunkFactoryFactory = <
    DataType extends Record<string, unknown>,
    LiteralName extends string,
    T,
    ServiceOperations extends string,
    ThrowOnError extends boolean = false,
>(
        sliceName: string,
        apiService: ClassConstructor<T>
    ): Record<GeneratedThunkNames<LiteralName, ServiceOperations>,
        ReturnType<typeof asyncThunkFactory<DataType, Record<string, unknown>, ThrowOnError>>> => {

    //GeneratedThunkRecord<LiteralName, DataType, ThrowOnError>
    const { staticMethods: serviceMethodNames } = getMethodNames<T>( apiService )

    type AsyncThunkFactoryReturn = ReturnType<typeof asyncThunkFactory<DataType, Record<string, unknown>, ThrowOnError>>

    const thunkMakers: Array<[
        string,
        AsyncThunkFactoryReturn
     ]> = serviceMethodNames.map( serviceMethodName => {

         // eslint-disable-next-line max-len
         const method = ( apiService as Record<string, unknown> )[ serviceMethodName as keyof typeof apiService ] as MethodFn<ApiDataResponseBody<DataType>, AppThunkErrors, Record<string, unknown>, ThrowOnError>

         const thunk: AsyncThunkFactoryReturn = asyncThunkFactory(
             sliceName,
             serviceMethodName,
             method.bind( new apiService() )
         )

         const thunkName = serviceMethodName.toLowerCase().includes( sliceName.toLowerCase() )
             ? serviceMethodName
             : serviceMethodName + sliceName.charAt( 0 ).toUpperCase() + sliceName.slice( 1 )

         return [ thunkName, thunk ]
     } )

    const keyedThunks = Object.fromEntries(
        thunkMakers
    ) as Record<
            GeneratedThunkNames<LiteralName, ServiceOperations>,
            ReturnType<typeof asyncThunkFactory<DataType, Record<string, unknown>, ThrowOnError>>
        >

    return keyedThunks
}


/** All the service method operation types */
type CRUDServiceOperations = "get" | "getAll" | "create" | "update" | "delete"

/** All the service method names for a slice name */
type GeneratedThunkNames<SliceName extends string, ServiceOperations extends string = CRUDServiceOperations> = {
    [K in ServiceOperations]: Pluralize<K, "getAll", `${K}${SliceName}`>;
}[ServiceOperations];

/** A record of the generated thunks */
type GeneratedThunkRecord<
    SliceName extends string,
    DataType extends Record<string, unknown>,
    ServiceOperations extends string = CRUDServiceOperations,
    ThrowOnError extends boolean = false
> = {
    [K in GeneratedThunkNames<SliceName, ServiceOperations>]: ReturnType<typeof asyncThunkFactory<DataType, Record<string, unknown>, ThrowOnError>>;
}

/** The typing for the extra state updating reducer */
interface AppSliceReducersTypes<DataType, ExtraStateType extends Record<string, unknown>> {
    updateExtraState: ( state: WritableDraft<AppSliceState<DataType, ExtraStateType>>, action: PayloadAction<ExtraStateType> ) =>
        WritableDraft<AppSliceState<DataType, ExtraStateType>>;
    clearState: () => AppSliceState<DataType, ExtraStateType>
}

/**
 * Factory function that takes a class generated by `@hey-api/client-axios`
 * and creates a Redux slice with thunks for all its methods.
 *
 * @param sliceName - The name of the slice - the generated Async thunks will be named `{sliceName}/{apiServiceMethodName}`
 * @param apiService - The service class from the generated `@hey-api/client-axios` client
 * @param extraState - Any extra state properties for initialState.extraState
 * @param thunkStateTargets - Mapping between thunk names and extraState property names, the thunk saves its success data there instead of state.data
 *
 * @typeParam DataType - The type of the data that all the service methods resolve to
 * @typeParam LiteralName - String literal type of the sliceName
 * @typeParam T - The type of `apiService` - the generated service class
 * @typeParam ServiceOperations - Literal string union for the names of the service classes methods
 * @typeParam ThrowOnError - internal to `@hey-api/client-axios` options
 */
const sliceFactory = <
    DataType extends Record<string, unknown>,
    T,
    LiteralName extends string,
    ServiceOperations extends string = CRUDServiceOperations,
    ExtraStateType extends Record<string, unknown> = Record<string, unknown>,
    ThrowOnError extends boolean = false,
>(
        sliceName: string,
        apiService: ClassConstructor<T>,
        extraState?: ExtraStateType,
        thunkStateTargets?: Record<string, string>,
    ): [
        Slice<
            AppSliceState<DataType, ExtraStateType>,
            SliceCaseReducers<AppSliceState<DataType, ExtraStateType>> & AppSliceReducersTypes<DataType, ExtraStateType>,
            string,
            string,
            SliceSelectors<AppSliceState<DataType, ExtraStateType>>
        >,
        GeneratedThunkRecord<LiteralName, DataType, ServiceOperations, ThrowOnError>,
        Record<string, ReturnType<ReturnType<typeof asyncThunkFactory<DataType, Record<string, unknown>, ThrowOnError>>>>,
     ] => {

    type AsyncThunkFactoryReturnType = ReturnType<typeof asyncThunkFactory<DataType, Record<string, unknown>, ThrowOnError>>
    const thunkMakers = asyncThunkFactoryFactory<DataType, LiteralName, T, ServiceOperations, ThrowOnError>( sliceName, apiService )
    const untypedThunks: Record<string, ReturnType<AsyncThunkFactoryReturnType>> = {}

    type ThisSliceState = AppSliceState<DataType, ExtraStateType>

    type ThisDataResponseBody = ApiDataResponseBody<DataType>

    extraState ??= { } as ExtraStateType
    const initialState: ThisSliceState = {
        data       : [],
        status     : SliceStatus.Idle,
        errors     : undefined,
        messages   : [],
        extraState : extraState
    }
    thunkStateTargets ??= {}

    const slice = createSlice( {
        name         : sliceName,
        initialState : initialState,
        reducers     : {
            clearState( ) {
                return initialState
            },
            updateExtraState( state, action: PayloadAction<Partial<ExtraStateType>> ) {
                ( state.extraState as Partial<ExtraStateType> ) = { ...state.extraState, ...action.payload }
                return state
            }
        },
        extraReducers: ( builder: ActionReducerMapBuilder<typeof initialState> ) => {

            const builderCaseBuilder = <
                ThunkArg,
                Returned extends ThisDataResponseBody,
                // C extends AppAsyncThunkConfig
            >(
                    innerBuilder: typeof builder,

                    // I'd rather pass C here but GetPendingMeta<C> on the PayloadAction seems to fail
                    asyncThunk: AsyncThunk<Returned, ThunkArg, AppAsyncThunkConfig>
                ) => {

                innerBuilder
                    .addCase( asyncThunk.pending, ( state, action ) => {
                        console.log( `PENDING: ${asyncThunk.typePrefix}`, action )
                        // state.meta = action.meta
                        state.type = action.type

                        state.status = SliceStatus.Loading

                        state.messages.push(
                            {
                                thunkTypePrefix : asyncThunk.typePrefix,
                                fromThunkState  : "pending",
                                message         : "Loading",
                                createdAt       : new Date().getTime()
                            }
                        )
                    } )
                    .addCase( asyncThunk.fulfilled, ( state, action ) => {
                        console.log( `FULFILLED: ${asyncThunk.typePrefix}`, action )
                        // state.meta = action.meta // TODO: This saves the args in the action which may have sensitive info
                        state.type = action.type

                        state.status = SliceStatus.Succeeded
                        const { data, message, metadata } = action.payload

                        const resolvedData = Array.isArray( data ) ? data : [ data ] // Should I just update the API to always return an array?

                        const isApiDataResponse = Boolean( data ) && Boolean( message )
                        const thunkStateTarget = thunkStateTargets[ asyncThunk.typePrefix ]

                        if ( thunkStateTarget )
                            ( state.extraState as Record<string, unknown> )[ thunkStateTarget ] = isApiDataResponse ? data : action.payload
                        else
                            state.data = resolvedData

                        state.dataMetadata = metadata

                        state.messages.push(
                            {
                                thunkTypePrefix : asyncThunk.typePrefix,
                                fromThunkState  : "fulfilled",
                                message         : message,
                                createdAt       : new Date().getTime()
                            }
                        )

                    } )
                    .addCase( asyncThunk.rejected, ( state, action ) => {
                        console.log( `REJECTED: ${asyncThunk.typePrefix}`, action )
                        // state.meta = action.meta
                        state.type = action.type

                        if ( !action.payload || action.payload instanceof Error ) {
                            state.status = SliceStatus.Failed
                            state.messages.push(
                                {
                                    thunkTypePrefix : asyncThunk.typePrefix,
                                    fromThunkState  : "rejected",
                                    message         : "Data Failure",
                                    createdAt       : new Date().getTime()
                                }
                            )
                            return
                        }

                        const { errors, message } = action.payload

                        state.status = SliceStatus.Failed
                        state.errors = errors

                        state.messages.push(
                            {
                                thunkTypePrefix : asyncThunk.typePrefix,
                                fromThunkState  : "rejected",
                                message         : message,
                                errors          : errors,
                                createdAt       : new Date().getTime()
                            }
                        )
                    } )
            }

            Object.entries( thunkMakers ).forEach( ( [ thunkName, thunk ] ) => {
                const untypedThunkWrapper = thunk as AsyncThunkFactoryReturnType
                const untypedThunk: ReturnType<AsyncThunkFactoryReturnType> = untypedThunkWrapper()
                untypedThunks[ thunkName ] = untypedThunk
                builderCaseBuilder( builder, untypedThunk )
            } )
        }
    } )

    return [ slice, thunkMakers, untypedThunks ]
}


export { appAsyncThunk, asyncThunkFactory, asyncThunkFactoryFactory, sliceFactory }
export type { BaseInputOptions, MethodFn, AppSliceReducersTypes as ReducersTypes }